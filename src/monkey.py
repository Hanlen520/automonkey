#!/usr/bin/evn python# -*- coding:utf-8 -*-# @author: zhangzhao_lenovo@126.com# @date: 20161201# @version: 1.0.0.1001# 1 crash or anr , use blockcannry ,https://github.com/zhangzhao4444/AndroidPerformanceMonitor| http://www.open-open.com/lib/view/open1437298378412.html# 2 memleak , use leakcannry# 3 codecoverage, use emma, http://clasnake.net/emma_for_android/import time, sys, os, random, resys.path.append('..')import signalfrom optparse import OptionParserimport hashlibimport utilimport appiumdriverimport loggerimport adbdriverimport confimport sys,platformsys.setrecursionlimit(3000)logobj=logger.logobjdef profile(func):    def execute(*args, **kwargs):        t0 = time.time()        ret = func(*args, **kwargs)        t1 = time.time()        print(func.__name__ + ' : ' + str(t1-t0))        return ret    return executeclass stack:    def __init__(self):        self.items=[]    def isempty(self):        return len(self.items) == 0    def push(self,item):        self.items.append(item)    def pop(self):        return self.items.pop()    def head(self):        if not self.isempty(): return self.items[len(self.items)-1]    def tail(self):        if len(self.items) > 1:            return self.items[-2]        return []    def size(self):        return len(self.items)    def contains(self, item):        return item in self.items    def clear(self):        self.items=[]    # def print(self):    #     for i in self.items: print(i)class record():    def __init__(self):        self.record = []        self.size = 10    def append(self , data):        self.record.append((time.time(),data))    def pop(self):        self.record.pop()    def interval(self):        if len(self.record) < 2:            return 0        else:            last1,_ = self.record[-1]            last2,_ = self.record[-2]            return last1-last2    def isdiff(self):        if len(self.record) < 2:            return False        else:            _, last1 = self.record[-1]            _, last2 = self.record[-2]            return last1 != last2    def isdiff3(self):        if len(self.record) < 3:            return False        else:            _, last1 = self.record[-1]            _, last3 = self.record[-3]            return last1 != last3    def last(self):        if not self.record: return None        if len(self.record) <2: _,last = self.record[0]        else: _,last = self.record[-1]        return last    def lastt(self):        if not self.record: return time.time()        lt,_ = self.record[-1]        return lt    def pre(self):        if len(self.record) >1:_,pre = self.record[-2]        else:_,pre = self.record[-1]        return pre    def lastn(self,n):        last = []        for x in range(1, n + 1):            if x < len(self.record) +1 :                _,data = self.record[-x]                last.append(data)        return last[::-1]    # def print(self):    #     for i in self.record: print(i)class urlelement():    def __init__(self,url,tag,id,name,loc=''):        self.url = url        self.tag = tag        self.id = id        self.name = name        self.loc = loc    def toloc(self):        #return 'url='+self.url+' | loc='+self.loc+' | tag='+self.tag+' | id='+self.id+' | name='+self.name        return 'url=' + self.url + ' | tag=' + self.tag + ' | id=' + self.id + ' | name=' + self.name    def tofilename(self):        return self.url.split('/')[-1].replace("[\\\\/?\"*<>\\|\n ]",'')    def tostring(self):        return self.url+','+self.tag+','+self.id+','+self.name +','+self.locclass elementinfo():    def __init__(self):        self.reqdom = ''        self.resdom = ''        self.reqhash = ''        self.reshash = ''        self.reqimg = ''        self.resimg = ''        self.clickedindex = -1        self.action = 'ready'        self.element = urlelement("","","","","")class image():    def __init__(self):        self.png = Noneclass urlelementstore():    def __init__(self):        self.elementstore = {}        self.clickedelementlist = []    def setskip(self,element):        self.clickedelementlist.remove(len(self.clickedelementlist)-1)        if element.tostring() not in self.elementstore:            self.elementstore[element.tostring()] = elementinfo()            self.elementstore[element.tostring()].element = element        self.elementstore[element.tostring()].action = 'skiped'    def setclicked(self,element):        if element.tostring() not in self.elementstore:            self.elementstore[element.tostring()] = elementinfo()            self.elementstore[element.tostring()].element = element        self.clickedelementlist.append(element)        self.elementstore[element.tostring()].action = 'clicked'        self.elementstore[element.tostring()].clickedindex = self.clickedelementlist.index(element)    def saveelement(self,element):        if element.tostring() not in self.elementstore:            self.elementstore[element.tostring()] = elementinfo()            self.elementstore[element.tostring()].element = element    def savehash(self,hash):        last = self.clickedelementlist[-1]        if not self.elementstore[last.tostring()].reqhash:            self.elementstore[last.tostring()].reqhash = hash        if len(self.clickedelementlist) > 1:            pre = self.clickedelementlist[-2]            self.elementstore[pre.tostring()].reshash = hash    def savedom(self,dom):        last = self.clickedelementlist[-1]        if not self.elementstore[last.tostring()].reqdom:            self.elementstore[last.tostring()].reqdom = dom        if len(self.clickedelementlist) > 1:            pre = self.clickedelementlist[-2]            self.elementstore[pre.tostring()].resdom = dom    def saveimg(self,img):        last = self.clickedelementlist[-1]        if not self.elementstore[last.tostring()].reqimg:            self.elementstore[last.tostring()].reqimg = img        if len(self.clickedelementlist) > 1:            pre = self.clickedelementlist[-2]            self.elementstore[pre.tostring()].resimg = img    def isdiff(self):        last = self.clickedelementlist[-1]        return self.elementstore[last.tostring()].reqhash != self.elementstore[last.tostring()].reshash    def isclicked(self,element):        if element.tostring()  in self.elementstore:            return self.elementstore[element.tostring()].action == 'clicked'        return False    def isskiped(self,element):        if element.tostring()  in self.elementstore:            return self.elementstore[element.tostring()].action == 'skiped'        return False    # def print(self):    #     for i in self.clickedelementlist:    #         logobj.info(i)    #         logobj.info(i.tostring())    #     for k,v in self.elementstore.items():    #         logobj.info('element key = '+ k)    #         #logobj.info('reqdom = '+ v.reqdom)    #         #logobj.info('resdom = '+ v.resdom)    #         logobj.info('reqhash = '+ v.reqhash)    #         logobj.info('reshash = ' + v.reshash)    #         logobj.info('reqimg = ')    #         logobj.info(v.reqimg)    #         logobj.info('resimg = ')    #         logobj.info(v.resimg)    #         logobj.info('clickedindex = ' + str(v.clickedindex))    #         logobj.info('action = ' + v.action)    #         logobj.info('\n')class Crawler():    def __init__(self,cmd):        self.driver = None        self.adb = None        self.config,self.caps,self.port,self.report = self.parsecmd(cmd)        self.timestamp = time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime(time.time()))        #self.resultdir = self.config['resultDir'] + '\\' + self.timestamp        self.resultdir = self.config['resultDir'] + os.path.sep + self.timestamp        self.store = urlelementstore()        self.currentaction = 'click'        self.automationname = 'appium'        self.screenwigth = 0        self.screenheight = 0        self.appname = ''        self.currentpagesource = ''        self.currentpagedom = None        self.currenturl = ''        self.backretry = 0        self.backmaxretry = 5        self.swiperetry = 0        self.swipemaxretry = 2        self.stopall = False        self.signalint = 0        self.starttime = time.time()        self.urlstack = stack()        self.backdistance = record()        self.appnamerecord = record()        self.contenthash = record()        self.platformname = self.config['currentDriver']        self.img = image()        self.appwhitelist = []        self.needswipe = []        self.url = ''        self.running = True        self.appiummonitorexit = False        self.finished = False        self.maybedialog = False        self.anyurlwilldo = list(self.config['elementActionsInanyURLwilldo'])        self.notusegt = ['96e73657','22c41bc']        self.baseinfo = []        self.coverageinfo = []        self.crashinfo = []        self.anrinfo = []        self.tombinfo = []        self.oominfo = []        self.perfinfo = []        self.pageobjects = {}    def distinct(self,list):        newlist = []        [newlist.append(i) for i in list if not i in newlist]        return newlist    def md5(self,str):        m = hashlib.md5()        m.update(str.encode(encoding = 'utf-8'))        return m.hexdigest()    def lastindexof(self,list,item):        tmp = list[::-1]        x = tmp.index(item)        l = len(list)        return l-x-1    def issmall(self,e):        if 'bounds' not in e or not e['bounds'] :return False        #"bounds": "[282,1782][539,1920]"        [x1, y1, x2, y2] = re.compile(r'(\d+)').findall(e['bounds'])        if int(x2) - int(x1) < 40 and int(y2) - int(y1) < 40: return True        return False    def isvalid(self,e):        if ('visible' not in e or e['visible'].lower() == 'true') \                and ('enabled' not in e or e['enabled'].lower() == 'true')\                and ('valid' not in e or e['valid'].lower() == 'true')\                and (self.issmall(e) == False):return True        return False    def isurlelementsame(self,x,y):        if x.name ==y.name and x.url == y.url and x.tag == y.tag and x.loc == y.loc and x.id == y.id : return True        return False    def isreturn(self):        for urlblack in self.config['urlBlackList']:            if re.compile(urlblack).findall(self.urlstack.head()):                logobj.warn(self.urlstack.head()+' in urlBlackList should return')                return True        for urlwhite in self.config['urlWhiteList']:            if not re.compile(urlwhite).findall(self.urlstack.head())\                    and re.compile(urlwhite).findall(self.urlstack.tail()):                logobj.warn(self.urlstack.head() + ' not in urlWhiteList should return')                return True        if re.compile('.*browser').findall(self.appname) :            logobj.warn('current app is browser, back')            return True        if self.swiperetry > self.swipemaxretry:            self.swiperetry = 0            logobj.warn('swipe retry too many times %s > %s'%(self.swiperetry,self.swipemaxretry))            return True        logobj.info("urlStack=%s baseUrl=%s maxDepth=%s" %(self.urlstack.items,self.config['baseUrl'],self.config['maxDepth']))        if len(self.urlstack.items) > self.config['maxDepth']:            logobj.warn('urlStack.depth=%s > maxDepth=%s'%(len(self.urlstack.items),self.config['maxDepth']))            return True        for url in self.urlstack.items:            if re.compile('Launcher.*').findall(url) \                    or re.compile('com.android\\..*').findall(self.appname) :                logobj.warn('maybe back to desktop. urlstack= %s'%self.urlstack.items)                return True        return False    def iscrash(self):        crash =['无响应','is not responding','ANR','crash','终止运行','停止运行','意外终止','结束运行']        nodes = self.getallelements("//*", 0)        for key in crash:            for node in nodes:                if ('text' in node and re.compile(key).findall(node['text'])) or 'content-desc' in node and re.compile(key).findall(node['content-desc']):                    if not os.path.exists(self.resultdir): os.makedirs(self.resultdir)                    timestamp = time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime(time.time()))                    png = self.resultdir + os.path.sep + 'CRASH_%s'%timestamp + '.png'                    logobj.info('Appear crash!!!!! save screen =%s'%png)                    appiumdriver.screenshot(self.driver,png)    def isbackapp(self):         if self.appnamerecord.last() not in self.appwhitelist and self.appnamerecord.isdiff3():             logobj.warn('not in app white list %s'%self.config['appWhiteList'])             logobj.warn("jump to other app appName=%s lastAppName=%s"%(self.appnamerecord.last(),self.appnamerecord.pre()))             self.setelementaction('backapp')             self.iscrash()             return True         return False    def isexit(self):        if time.time() - self.starttime > int(self.config['maxTime']) * 1000:            logobj.warn("maxTime out Quit need exit")            return True        if self.backretry > self.backmaxretry:            logobj.warn('backRetry=%s > backMaxRetry=%s need exit'%(self.backretry,self.backmaxretry))            return True        if len(self.appnamerecord.record) < 5: return False        for app in self.appnamerecord.lastn(5):            if app in self.appwhitelist:                return False        logobj.error('appNameRecord last 5 %s' % self.appnamerecord.lastn(5))        return True    def getbasepathname(self,element=''):        if not element : element = self.store.clickedelementlist[-1]        return self.config['resultDir'] + str(self.lastindexof(self.store.clickedelementlist,element)) + '_' + element.tofilename()    def getappname(self):        list = self.getallelements("(//*[@package!=''])[1]",0)        if list:            appname = list[0]['package']            if appname: return appname        return ''    def getcontenthash(self):        nodes = self.getallelements("//*[not(ancestor-or-self::UIAStatusBar)]",0)        str = ''        try:            for node in nodes:                s = ''                if 'tag' in node and \                                node['tag'] in self.config['schemaBlackList']: continue                for x in ['xpath', 'value', 'selected', 'text']:                    if x in node and node[x]: s += node[x]                str += s + '\n'        except Exception as e:            return self.md5('None')        return self.md5(str)    # geturl : 0.22500014305114746    def geturl(self):        url = []        screenname = ''        if self.appname : url.append(self.appname)        if self.automationname == 'appium':            currentactivity = (appiumdriver.asynctask(appiumdriver.getcurrentactivity, self.driver, timeout=30))            if currentactivity and '.' in currentactivity:                screenname = currentactivity.split('.')[-1]        if screenname : url.append(screenname)        if self.config['defineUrl']:            for xpath in self.config['defineUrl']:                baselist = self.getallelements(xpath,0)                if baselist:                    for base in baselist:                        if 'attribute' in base:                            base['attribute'] and url.append(base['attribute'])                        else:                            'label' in base and base['label'] and url.append(base['label']) \                            or 'name' in base and base['name'] and url.append(base['name'])        url = self.distinct(url)        #logobj.debug('defineUrl = %s'%url)        return '-'.join(url)    def getbackbutton(self):        for xpath in self.config['backButton']:            nodes = self.getallelements(xpath,0)            if nodes and not self.appnamerecord.isdiff():                e = self.geturlelementbymap(nodes[0])                backelement = urlelement(e.url, e.tag, e.name, e.name+'-'+str(len(self.store.clickedelementlist)), e.loc)                self.setelementaction('click')                #logobj.debug('backbutton is %s,%s,%s'%(e.name,e.url,e.loc))                return backelement        self.setelementaction('back')        return urlelement(self.currenturl, '', '','back-'+str(len(self.store.clickedelementlist)))    def getelementaction(self):        return self.currentaction    def setelementaction(self, action):        self.currentaction = action    def getallelements(self, xpath,israndom=1):        #logobj.debug('xpath = %s ,get list'%xpath)        elementlist = []        for element in appiumdriver.xpathtolist(xpath, self.currentpagesource):            self.isvalid(element) and elementlist.append(element)        if elementlist:            if israndom and self.config['randomselect'] and len(elementlist) > 1 : random.shuffle(elementlist)            return elementlist        else: return []    def geturlelementbymap(self, x):        tag = 'notag'        name = ''        id = ''        loc = ''        if 'tag' in x and x['tag']: tag = x['tag']        if 'value' in x and x['value'] : name = x['value'].replace('\n','\\n')        if 'name' in x and x['name'] : id = x['name'].split('/')[-1]        if 'xpath' in x and x['xpath'] : loc = x['xpath']        return urlelement(self.currenturl, tag, id, name, loc)    def getelementbyelementaction(self):        for x in self.config['elementActions']:            nodes = []            if 'pri' not in x or x['pri'] ==1:                index = 0                action = x['action']                xpath = x['idOrName']                if 'time' in x: times = x['times']                else: times = 1                if 'index' in x: index = x['index']                if 'url' in x:                    url = x['url']                    if not re.compile(url).findall(self.currenturl): continue                xpathpattern = re.compile('/.*')                if xpathpattern.findall(xpath):                    nodes = self.getallelements(xpath,0)                else:                    allnodes = self.getallelements("//*",0)                    attrpattern = re.compile(xpath)                    for node in allnodes:                        if ('name' in node and attrpattern.findall(node['name'])) \                                or 'value' in node and attrpattern.findall(node['value']):                            nodes.append(node)                if nodes:                    self.config['elementActions'].remove(x)                    if 'time' in x: x['times'] -= 1                    if times != 1:                        self.config['elementActions'].append(x)                    self.setelementaction(action)                    if action == 'monkey':                        size = len(self.config['monkeyEvents'])                        code = self.config['monkeyEvents'][random.randint(size)]                        return urlelement('monkey', '', '', str(code), 'event-'+str(code))                    else:                        if len(nodes) > index: return self.geturlelementbymap(nodes[index])                        return self.geturlelementbymap(nodes[0])        return None    def getelementbyelementactioninanyurlwilldo(self):        for x in self.anyurlwilldo:            nodes = []            index = 0            action = x['action']            xpath = x['idOrName']            if 'time' in x :times = x['times']            else: times=1            if 'index' in x: index = x['index']            if 'url' in x:                if not re.compile(x['url']).findall(self.currenturl): continue            if re.compile('/.*').findall(xpath): nodes = self.getallelements(xpath, 0)            else:                allnodes = self.getallelements("//*", 0)                attrpattern = re.compile(xpath)                for node in allnodes:                    if ('name' in node and attrpattern.findall(node['name'])) \                            or 'value' in node and attrpattern.findall(node['value']): nodes.append(node)            if nodes:                for y in self.config['elementActionsInanyURLwilldo']:                    if y['idOrName'] == xpath:                        self.config['elementActionsInanyURLwilldo'].remove(y)                        if 'total' in y:                            y['total'] -= 1                            if y['total']!=1:self.config['elementActionsInanyURLwilldo'].append(y)                        else:                            self.config['elementActionsInanyURLwilldo'].append(y)                self.anyurlwilldo.remove(x)                if 'time' in x : x['times'] -= 1                if times != 1:                    self.anyurlwilldo.append(x)                self.setelementaction(action)                if len(nodes) > index: return self.geturlelementbymap(nodes[index])                return self.geturlelementbymap(nodes[0])        return None    def getactionbyelementaction(self, element):        for x in self.config['elementActions']:            nodes = []            if 'pri' in x and x['pri'] == 0:                xpath = x['idOrName']                action = x['action']                if re.compile('/.*').findall(xpath):                    nodes = self.getallelements(xpath,0)                else:                    for node in self.getallelements("//*",0):                        if ('name' in node and re.compile(xpath).findall(node['name'])) \                                or 'value' in node and re.compile(xpath).findall(node['value']):                            nodes.append(node)                for node in self.distinct(nodes):                    spelement = self.geturlelementbymap(node)                    if self.isurlelementsame(spelement,element):                        return action        return 'click'    # getselectedelements: 0.018000125885009766    def getselectedelements(self):        all = []        first= []        last = []        select = []        black = []        allelements = self.getallelements('//*')        #logobj.debug('allelements length = %s'%len(allelements))        for xpath in self.config['blackList']:            #logobj.debug(xpath)            if re.compile('/.*').findall(xpath):                for i in self.getallelements(xpath):                    black.append(i)            else:                for i in self.getallelements("//*"):                    if ('name' in i and re.compile(xpath).findall(i['name'])) \                            or 'value' in i and re.compile(xpath).findall(i['value']):                        black.append(i)        black = self.distinct(black)        #logobj.debug('black = %s ,length = %s'%(black,len(black)))        for xpath in self.config['selectedList']:            for i in self.getallelements(xpath):                select.append(i)        select = self.distinct(select)        #logobj.debug('select = %s ,length = %s'%(select,len(select)))        select = [i for i in select if i not in black]        #logobj.debug('select-black = %s ,length = %s'%(select,len(select)))        for xpath in self.config['firstList']:            for i in self.getallelements(xpath):                i in select and first.append(i)        first = self.distinct(first)        #logobj.debug('first = %s ,length = %s'%(first,len(first)))        for xpath in self.config['lastList']:            for i in self.getallelements(xpath):                i in select and last.append(i)        last = self.distinct(last)        #logobj.debug('last = %s ,length = %s'%(last,len(last)))        select = [i for i in select if i not in first and i not in last]        if self.config['randomselect']:            random.shuffle(select)            random.shuffle(last)        #logobj.debug('select-first-last = %s ,length = %s'%(select,len(select)))        #all = list((set(first).union(set(select))).union(set(last)))        for x in [first,select,last]:            for y in x:                all.append(y)        all = self.distinct(all)        #logobj.debug('all selected = %s ,length = %s'%(all,len(all)))        return all    def isinbounds(self, x, node):        if 'bounds' in x:            [x1, y1, x2, y2] = re.compile(r'(\d+)').findall(x['bounds'])            [xn1, yn1, xn2, yn2] = re.compile(r'(\d+)').findall(node['bounds'])            # bounds:"[10,1200][1000,1900]"            # [795,1725][933,1863]            if (int(xn1) > int(x1) and int(yn1) > int(y1) and int(xn2) < int(x2) and int(yn2) < int(y2)): return True        return False    def filterblackelements(self, all):        black = []        for partten in self.config['blackList']:            if re.compile('/.*').findall(partten): continue            for node in all:                if ('name' in node and  re.compile(partten).findall(node['name'])) \                        or ('value' in node and re.compile(partten).findall(node['value'])) \                        or ('label' in node and re.compile(partten).findall(node['label'])): black.append(node)        #logobj.debug('black = %s ,length = %s' % (black, len(black)))        #1221 new feature, extrablack        for x in self.config['extrablackList']:            xpath = x['key']            if 'url' in x and not re.compile(x['url']).findall(self.currenturl) : continue            if re.compile('/.*').findall(xpath):                for node in self.getallelements(xpath):                    if not self.isinbounds(x, node): continue                    black.append(node)            else:                for node in all:                    if not self.isinbounds(x,node) :continue                    if ('name' in node and  re.compile(partten).findall(node['name'])) \                        or ('value' in node and re.compile(partten).findall(node['value'])) \                        or ('label' in node and re.compile(partten).findall(node['label'])): black.append(node)        #logobj.debug('black+extrablack = %s ,length = %s' % (black, len(black)))        return [i for i in all if i not in black]    def filterbackelements(self, all):        back =[]        for xpath in self.config['backButton']:            for node in self.getallelements(xpath): back.append(node)        return [i for i in all if i not in back]    def getavailableelement(self):        all = self.getselectedelements()        #logobj.info('all nodes size = %s'%len(all))        all = self.filterblackelements(all)        #logobj.info('all - black size = %s'%len(all))        all = self.filterbackelements(all)        #logobj.info('all - back size = %s'%len(all))        elements =[]        for node in all:            element = self.geturlelementbymap(node)            if not self.store.isclicked(element) and not self.store.isskiped(element):                self.store.saveelement(element)                elements.append(element)        logobj.info('all element size = %s , Not click size = %s'%(len(all),len(elements)))        if not len(elements)-1 and self.currenturl not in self.needswipe: self.needswipe.append(self.currenturl)        logobj.debug('needswipe stack=%s'%self.needswipe)        return elements    def findelementbyurlelement(self,urlelement):        #xpath = urlelement.loc.replace('hierarchy', '')        webelements = appiumdriver.find(self.driver, appiumdriver.By.XPATH, urlelement.loc)        if webelements: return webelements[0]        return None    def doback(self):        if self.backdistance.interval() < 4:            logobj.warn('two back action to close!')            time.sleep(4)        ret = appiumdriver.asynctask(appiumdriver.back, self.driver)        logobj.debug('back event return=%s'%ret)        self.backdistance.append('back')        if ret : self.appnamerecord.pop()    def dobackapp(self):        if self.config['defaultBackAction']:            for backaction in self.config['defaultBackAction']:                appiumdriver.dsl(self.driver, backaction)        else:            appiumdriver.backapp(self.driver, self.caps['appPackage'], self.caps['appActivity'])    def hidekeyboardios(self):        if self.getallelements('//UIAKeyboard'):            logobj.info('find keyboard, just hide')            appiumdriver.hidekeyboard(self.driver)    # doelementaction : 0.7660000324249268    def doelementaction(self, element, action, **kw):        logobj.info('current element=%s'% element.name)        #logobj.info('current xpath=%s' % element.loc)        logobj.info('current %s' % element.toloc())        # logobj.info('current url = %s' % element.url)        #logobj.info('current index = %s' % (len(self.store.clickedelementlist)-1))        logobj.info('do %s' % action)        if action == 'tap':            # self.savedom()            # self.savescreen()            appiumdriver.tapelement(self.driver, element)        if action == 'back':            #logobj.info('do back')            # self.savedom()            # self.savescreen()            self.doback()        if action == 'backapp':            # self.savedom()            # self.savescreen()            self.dobackapp()        if action == 'monkey':            # self.savedom()            # self.savescreen()            appiumdriver.event(self.driver, int(element.name))        if re.compile('.*\\(.*\\).*').findall(action):            appiumdriver.dsl(self.driver, action)        if isinstance(action, str):            webelement = self.findelementbyurlelement(element)            if webelement:                # self.savedom()                # self.savescreen()                if action == 'click':                    appiumdriver.asynctask(webelement.click)                else:                    # win appium 1.4                    if 'Windows' in platform.system():appiumdriver.asynctask(webelement.send_keys,action)                    # linux appium 1.6                    else: appiumdriver.asynctask(webelement.set_value, action)            # else:            #     self.savedom()            #     self.savescreen()            for ime in ['UIATextField', 'UIATextView', 'EditText']:                if re.compile(ime).findall(element.tag):                    self.hidekeyboardios()    def afterelementaction(self,element):        action = self.getelementaction()        if action !='skip':            self.refreshpage()        if action =='back' or action == 'backapp':            self.backretry +=1        else:            self.backretry = 0        # todo    def sourcetopageobject(self):        #logobj.debug(self.pageobjects)        app = self.currenturl.split('-')[0]        if app != self.config['androidCapability']['appPackage']:            print('1')            return        url = self.currenturl.split('-')[-1]        #logobj.debug(url)        if url not in self.pageobjects:            self.pageobjects[url] = {}        nodes = appiumdriver.xpathtolist('//*', self.currentpagesource)        for node in nodes:            if 'resource-id' not in node and 'name' not in node: continue            if 'resource-id' in node and node['resource-id'] or 'name' in node and node['name']:                # text =''                id = node['resource-id'] or node['name']                id = id.split('/')[-1]                xpath = "//*["                for attr in ['resource-id', 'class', 'package', 'content-desc', 'clickable']:                    if attr in node and node[attr]:                        xpath += "@%s='%s' and " % (attr, node[attr])                xpath = xpath[0:-5] + ']'                location = (0, 0, 0, 0, 0, 0)                if 'bounds' in node and node['bounds']:                    [x1, y1, x2, y2] = re.compile(r'(\d+)').findall(node['bounds'])                    location = '%s,%s,%s,%s,%s,%s' % (                    int(x1), int(y1), int(x2) - int(x1), int(y2) - int(y1), int(int(x1) + (int(x2) - int(x1)) / 2),                    int(int(y1) + (int(y2) - int(y1)) / 2))                # if 'text' in node and node['text']:                #     text = node['text']                if id not in self.pageobjects[url]:                    self.pageobjects[url][id] = {}                    self.pageobjects[url][id]['location'] = location                    self.pageobjects[url][id]['xpath'] = xpath                    # pageobjects[url][id]['text'] = text        #logobj.debug(self.pageobjects)    def parsepagecontext(self):        self.appname = self.getappname()        if self.appname : self.appnamerecord.append(self.appname)        self.currenturl = self.geturl()        if self.config['pageobject'] and self.adb: # only android todo ios            self.sourcetopageobject()        if self.urlstack.head() != self.currenturl:            self.anyurlwilldo = list(self.config['elementActionsInanyURLwilldo'])        if (self.urlstack.contains(self.currenturl)):            while(self.urlstack.head() != self.currenturl):                self.urlstack.pop()        else:            self.urlstack.push(self.currenturl)        for baseurl in self.config['baseUrl']:            if (self.urlstack.head()==baseurl):                self.urlstack.clear()                self.urlstack.push(self.currenturl)        self.contenthash.append(self.getcontenthash())        if self.contenthash.isdiff():            logobj.info('current url=%s ,current Hash=%s ,last Hash=%s ,ui change!'%(self.currenturl,self.contenthash.last(),self.contenthash.pre()))        else:            logobj.info('current url=%s ,current Hash=%s ,last Hash=%s ,ui not change' % (self.currenturl, self.contenthash.last(), self.contenthash.pre()))        self.afterurlrefresh()    def refreshpage(self):        self.currentpagesource = ''        self.currentpagesource = appiumdriver.asynctask(appiumdriver.getpagesource, self.driver,timeout=60)        if self.currentpagesource:            self.parsepagecontext()            if self.getelementaction() == 'back' and self.currenturl in self.needswipe :                logobj.debug('needswipe=%s, need swipeto up' % self.needswipe)                for action in self.config['beforeRefreshpageAction']:                    appiumdriver.asynctask(appiumdriver.dsl, self.driver, action)                self.needswipe.remove(self.currenturl)                self.swiperetry += 1            return True        else:            self.setelementaction('back')            return False    #crawl : 2.2710001468658447    def crawl(self):        self.recursivenum += 1        self.isrefreshsuccess = True        self.skipbeforeelementaction = True        self.nextelement = None        if self.getelementaction() =='skip':            self.setelementaction('click')        else:            #time.sleep(0.2)            self.isrefreshsuccess = self.refreshpage()        if self.isexit():            return False        if self.isrefreshsuccess == False:            self.nextelement = urlelement(self.currenturl,'','','','back-'+str(len(self.store.clickedelementlist)))            self.setelementaction('back')        if self.isbackapp():            self.nextelement = urlelement(self.currenturl,'','','','backapp-'+self.appnamerecord.last() +'-'+ str(len(self.store.clickedelementlist)))            self.setelementaction('backapp')        if not self.nextelement:            self.nextelement = self.getelementbyelementaction()        if not self.nextelement:            self.nextelement =self.getelementbyelementactioninanyurlwilldo()        if not self.nextelement and self.isreturn():            self.nextelement = self.getbackbutton()        if not self.nextelement:            elements = self.getavailableelement()            if elements:                self.nextelement = elements[0]                self.setelementaction(self.getactionbyelementaction(self.nextelement))                self.skipbeforeelementaction = False            else:                self.setelementaction('back')                self.nextelement = self.getbackbutton()                self.afterurlfinshed()        if self.nextelement:            self.store.setclicked(self.nextelement)            self.store.savehash(self.contenthash.last())            self.store.saveimg(self.getbasepathname(self.nextelement) +"ps.jpg")            if not self.skipbeforeelementaction:                self.beforeelementaction(self.nextelement)            if self.getelementaction() == 'skip':                self.store.setskip(self.nextelement)            else:                appiumdriver.asynctask(self.doelementaction,self.nextelement,self.getelementaction(), timeout=60)                self.afterelementaction(self.nextelement)        self.crawl()####    def afterurlrefresh(self):        #todo        pass    def afterurlfinshed(self):        #todo        pass    def beforeelementaction(self,element):        #todo        pass    def savedom(self):        # todo bug!        #open(self.getbasepathname()+'.dom', "w").\            #write(''.join(random.choice(bytes(self.currentpagesource,'UTF-8')) for i in range(10 ** 7)))        pass    def savescreen(self):        # todo        pass####    def startupscript(self):        self.maybedialog = False        time.sleep(5)        for action in self.config['startupActions']:            appiumdriver.dsl(self.driver,action)            self.refreshpage()            self.store.setclicked(urlelement(self.currenturl,'','','',                                             "startupaction-"+action+'-'+str(len(self.store.clickedelementlist))))            self.store.savehash(self.contenthash.last())            self.store.saveimg(self.getbasepathname() + "ps.jpg")            # if self.store.isdiff() or not self.img.png :    too slow            #      self.img.png = appiumdriver.screenshotpng(self.driver)            # self.store.saveimg(self.img)            self.store.savedom(self.currentpagesource)            #self.savedom()            #self.savescreen()            #time.sleep(1)        #self.store.print()    def crawlercoverage(self):        self.coverage = {}        totalelement = 0        for k, v in self.store.elementstore.items():            try:                url = v.element.url.split('-')[1]            except Exception as e:                continue            if url in self.coverage:                noclick = self.coverage[url]['noclick']                total = self.coverage[url]['total']                del self.coverage[url]            else:                noclick = 0                total = 0            if v.clickedindex == -1: noclick += 1            total += 1            tmp = {}            tmp['total'] = total            tmp['noclick'] = noclick            self.coverage[url] = tmp            totalelement += 1        logobj.info('\n')        logobj.info('------coverage report------')        logobj.info('total clickable elements : %s'%totalelement)        self.coverageinfo.append(('total clickable elements:',totalelement))        for k,v in self.coverage.items():            total = int(v['total'])            clicked = int(v['total'])-int(v['noclick'])            logobj.info(('%s ：total %s elements, %s elements clicked, coverage=%02.2f'%(k,total,clicked,(clicked/total)*100)+'%'))            self.coverageinfo.append(('%s:'%k,'total %s elements, %s elements clicked, coverage=%02.2f'%(total,clicked,(clicked/total)*100)+'%'))        logobj.info('\n')        logobj.info('total testing time : %s s' %(time.time()-self.starttime))        self.baseinfo.append(('测试用时:','%.1f s'%(time.time()-self.starttime)))    def calcperformation(self):        if self.adb:            if not self.config['gt'] or self.udid in self.notusegt:                cpu = util.draw(self.udid, self.resultdir, self.timestamp, 'PerformanceTest', 'Times(s)', 'Percent',self.adb.cpu, 'cpu', 100)                # print(self.adb.cpu)                # print(self.adb.mem)                # print(self.adb.totalmem)                # print(len(self.adb.cpu))                # print(len(self.adb.mem))                time.sleep(5)                mem = util.draw(self.udid, self.resultdir, self.timestamp, 'PerformanceTest', 'Times(s)', 'Pss',self.adb.mem, 'mem', self.adb.totalmem)                if cpu: self.perfinfo.append(('cpu', cpu))                if mem: self.perfinfo.append(('mem', mem))            else:                try:                    totalmem = self.adb.getmemtotal()                except:                    totalmem = 2000                try:                    self.adb.stopandsavegttest(self.package, self.udid, self.timestamp, 'panda_gt', self.resultdir)                    time.sleep(20)                    file = util.getperformancefile(self.resultdir + os.path.sep + '%s_%s' % (self.udid, self.timestamp) + os.path.sep,'Pcp0_com.panda.videoliveplatform_')                    cpudata = util.getcpufromexecl(file)                    cpu = util.draw(self.udid, self.resultdir, self.timestamp, 'Performance Test', 'Times(s)','Percent', cpudata, 'cpu', 100)                    file = util.getperformancefile(self.resultdir + os.path.sep + '%s_%s' % (self.udid, self.timestamp) + os.path.sep,'Ps0_com.panda.videoliveplatform_')                    memtotal, memdalvik, memnative = util.getmemfromexecl(file)                    mem = util.draw(self.udid, self.resultdir, self.timestamp, 'PerformanceTest', 'Times(s)', 'Pss',memtotal, 'mem', totalmem, memdalvik, 'dalvik', memnative, 'native')                    if cpu: self.perfinfo.append(('cpu', cpu))                    if mem: self.perfinfo.append(('mem', mem))                    self.adb.cpu = cpudata                    self.adb.mem = memtotal                except Exception as e:                    print(e)    def calccrash(self):        if self.adb:            logfile = self.resultdir + os.path.sep +'logcat.txt'            #self.adb.logcat(logfile)            if not os.path.exists(logfile): return            self.adb.analyzelogcat(logfile,self.config['androidCapability']['appPackage'])            self.adb.clearlogcat()            logobj.info('crash =%s'%len(self.adb.crash))            if self.adb.crash:                self.crashinfo.append(('crash:',len(self.adb.crash)))                for i in self.adb.crash:                    id, log = i                    self.crashinfo.append((id,log))            logobj.info('oom =%s' % len(self.adb.oom))            if self.adb.oom:                self.crashinfo.append(('oom:', len(self.adb.oom)))                for i in self.adb.oom:                    id, log = i                    self.oominfo.append((id, log))            logobj.info('anr =%s' % len(self.adb.anr))            if self.adb.anr:                for i in self.adb.anr:                    self.anrinfo.append(('anr:',len(self.adb.anr)))                    id, log = i                    self.anrinfo.append((id,log))            logobj.info('native crash =%s' % len(self.adb.tombstone))            if self.adb.tombstone:                for i in self.adb.tombstone:                    self.tombinfo.append(('tombstone:', len(self.adb.tombstone)))                    id, log = i                    self.tombinfo.append((id,log))            # print(self.adb.crash)            # print(self.adb.anr)            # print(self.adb.tombstone)            # print(self.adb.oom)    def makereport(self):        if not self.report: self.report = self.resultdir + os.path.sep + 'testreport.html'        util.report(self.report, 'UI遍历测试', self.baseinfo, self.coverageinfo, self.crashinfo, self.anrinfo, self.tombinfo, self.oominfo, self.perfinfo)        #self.emailhtml = self.resultdir + os.path.sep + self.timestamp + os.path.sep + 'email.html'        self.emailhtml = self.report + '.email'        if self.perfinfo:            _, cpupng = self.perfinfo[0]            _, mempng = self.perfinfo[1]            cpupng = cpupng.split(os.path.sep)[-1]            mempng = mempng.split(os.path.sep)[-1]            cpupng = self.resultdir + os.path.sep + cpupng            mempng = self.resultdir + os.path.sep + mempng            perfinfo = []            perfinfo.append(('cpu', cpupng))            perfinfo.append(('mem', mempng))            self.perfinfo = perfinfo        util.emailreport_details(self.emailhtml, 'UI遍历测试', self.baseinfo, self.coverageinfo, self.crashinfo, self.anrinfo, self.tombinfo, self.oominfo, self.adb.cpu, self.adb.mem, self.perfinfo)    def makepageobject(self):        if self.pageobjects:            logobj.debug(self.pageobjects)            name = self.configfilepath.split(os.path.sep)[-1].split('.')[0]            file = '%s%sconf%s%s_pageobject.yml'%(os.path.split(os.path.realpath(__file__))[0],os.path.sep,os.path.sep,name)            util.writeyml(file,self.pageobjects)    def stop(self, signum, frame):        if self.running == True or self.appiummonitorexit == True:            self.running = False            self.appiummonitor = False            logobj.info('test finished!')            if self.config['pageobject']: self.makepageobject()            if not os.path.exists(self.resultdir): os.makedirs(self.resultdir)            self.calccrash()            self.crawlercoverage()            self.calcperformation()            self.makereport()            self.finished = True        if self.finished == True:sys.exit()    def registctrlc(self):        signal.signal(signal.SIGINT, self.stop)    def appiummonitor(self,**kw):        logobj.info('start hangup monitor!')        while self.running :            logobj.debug('/////////////////////// hangup time=%s!)))))))))))))))))))))))))))))'%(time.time()-self.appnamerecord.lastt()))            if time.time()-self.appnamerecord.lastt()>120:                logobj.error('###################################appium server not running or client hang-up!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')                port = self.port                try:                    logobj.debug('restart appium server')                    self.startserver()                    time.sleep(25)                    logobj.debug('restart appium client')                    self.restartclient()                    #self.stopserver(port)                    logobj.info('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@appium running$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')                except Exception as e:                    logobj.error('appium monitor crash!')                    logobj.error(e)                    self.running = False                    self.appiummonitorexit = True            time.sleep(60)    def clickstartupsysmenu(self, driver, startupClosePopenSysmenu, **kw):        while True:            if not self.maybedialog: break            appiumdriver.findSysmenu(driver, startupClosePopenSysmenu)        logobj.debug('findsysmenu thread quit.')    def dialogmonitor(self, **kw):        logobj.info('start sysdialog monitor!')        self.clickstartupsysmenu(self.driver,self.config['startupClosePopenSysmenu'])    def perfmonitor(self,internal,**kw):        if self.adb:            if not self.config['gt'] or self.udid in self.notusegt:                logobj.info('start performation monitor!')                appiumdriver.asynctask(self.adb.cpumonitor,self.package,internal, timeout=3)                appiumdriver.asynctask(self.adb.memmonitor,self.package,internal, timeout=3)                #appiumdriver.asynctask(self.adb.netmonitor, self.package, internal, timeout=3)            else:                self.adb.GTexit()                logobj.info('start GT performation monitor!')                self.adb.startgttestnogui(self.package)                #appiumdriver.startactivity(self.driver,self.package,self.config['androidCapability']['appActivity'])    def logcatmonitor(self,**kw):        if self.adb:            logobj.info('start logcat monitor!')            util.logcat(self.adb, self.resultdir)    def stopserver(self,port):        if appiumdriver.isrunning('http://127.0.0.1:%s/wd/hub' % port):            pass        logobj.info('stop old appium server, port=%s' % port)        time.sleep(1)    def startserver(self):        if not self.port: self.port = 4723        servertimeout = int(self.config['maxTime'])        self.port = appiumdriver.startappiumserver(self.port, servertimeout)        logobj.info('start appium server, port=%s' % self.port)    def startclient(self):        if os.path.splitext(self.apppath)[1] != '.apk' and os.path.splitext(self.apppath)[1] != '.ipa':            self.url = 'http://127.0.0.1:%s/wd/hub' % self.port            self.driver = appiumdriver.startappiumclient(self.url, self.caps)            logobj.info('start appium client, url=%s' % self.url)        else:            self.caps['noReset'] = True            self.url = 'http://127.0.0.1:%s/wd/hub' % self.port            if self.adb: self.adb.installsucc = True            self.maybedialog = True            self.driver = appiumdriver.startappiumclient(self.url, self.caps)            logobj.info('start appium client, url=%s' % self.url)        time.sleep(1)    def restartclient(self):        self.url = 'http://127.0.0.1:%s/wd/hub' % self.port        self.caps['noReset'] = True        self.driver = appiumdriver.startappiumclient(self.url, self.caps)        logobj.info('restart appium client, url=%s' % self.url)        time.sleep(1)    def startadbinstall(self):        deviceinfo = {'SM-G9208': 'samsung s6'}        self.apppath = self.config['capability']['app']        self.udid = self.config['capability']['udid']        self.package = self.config['androidCapability']['appPackage']        if not self.apppath or not self.udid:            logobj.error('miss param -a or -i,exit!')            sys.exit()        if os.path.splitext(self.apppath)[1] == '.apk':            self.adb = adbdriver.ADB(self.udid)            self.baseinfo.append(('包名:',self.package))            self.baseinfo.append(('安装包:',os.path.basename(self.apppath)))            self.baseinfo.append(('设备ID:',self.udid))            devicemodel = self.adb.getdevicemodel()            model = ''            if devicemodel in deviceinfo:                model = deviceinfo[devicemodel]            self.baseinfo.append(('机型:',model))            androidversion = self.adb.getandroidversion()            self.baseinfo.append(('版本:','Android %s'%androidversion))            x,y = self.adb.getscreenhw()            self.baseinfo.append(('分辨率:','%s*%s'%(x,y)))            appiumdriver.asynctask(self.adb.install,self.package,self.apppath,timeout=3)            appiumdriver.asynctask(self.adb.clickinstallerbutton,timeout=3)        if self.config['pageobject']: # only android todo ios            name = self.configfilepath.split(os.path.sep)[-1].split('.')[0]            file = '%s%sconf%s%s_pageobject.yml' % (os.path.split(os.path.realpath(__file__))[0], os.path.sep, os.path.sep, name)            if os.path.exists(file):                self.pageobjects = util.readyml(file)    def start(self):        self.registctrlc()        self.startadbinstall()        self.startserver()        time.sleep(25)        self.startclient()        self.perfmonitor(2)        appiumdriver.asynctask(self.appiummonitor,timeout=3)        appiumdriver.asynctask(self.dialogmonitor,timeout=3)        appiumdriver.asynctask(self.logcatmonitor, timeout=3)        appiumdriver.back(self.driver)  # bugfix xiaomi popup appupdate menu        self.screenheight,self.screenwigth = appiumdriver.getscreenhw(self.driver)        time.sleep(15)        self.startupscript()        self.appwhitelist.append(self.appnamerecord.last())        keep = True        execption = 0        while keep:            try:                self.recursivenum = 0                keep = self.crawl()                logobj.debug('recursive num = %s'%self.recursivenum)            except Exception as e:                logobj.error(e)                execption += 1                time.sleep(60)                if execption > 10:                    keep = False        self.stop(None,None)    def parsecmd(self,cmd):        caps = {}        #cmd        # appiumserver = cmd.appium        # config = conf.Conf().load(os.path.realpath(cmd.config))        # self.configfilepath = os.path.realpath(cmd.config)        # if cmd.maxtime : config['maxTime'] = cmd.maxtime        # if cmd.udid: config['capability']['udid'] = cmd.udid        # if cmd.app :        #     config['capability']['app'] = os.path.realpath(cmd.app)        #     self.apppath = os.path.realpath(cmd.app)        # if cmd.platform in ['android','ios'] : config['capability']['platformName'] = cmd.platform.lower()        # if cmd.output : config['resultDir'] = cmd.output        # if not cmd.port : port = 4723        # else: port = cmd.port        # report = ''        # if cmd.report : report = cmd.report        # caps = config['capability']        # if os.path.splitext(cmd.app)[1] == '.apk':        #     for k,v in config['androidCapability'].items():        #         if v: caps[k] = v        # elif os.path.splitext(cmd.app)[1] == '.ipa':        #     for k,v in config['iosCapability'].items():        #         if v: caps[k] = v        #cmd        #debug        appiumserver = cmd['appium']        config = conf.Conf().load(os.path.realpath(cmd['config']))        self.configfilepath = os.path.realpath(cmd['config'])        if cmd['maxtime'] : config['maxTime'] = cmd['maxtime']        if cmd['udid']: config['capability']['udid'] = cmd['udid']        if cmd['app'] :            config['capability']['app'] = os.path.realpath(cmd['app'])            self.apppath = os.path.realpath(cmd['app'])        if cmd['platform'] in ['android','ios'] : config['capability']['platformName'] = cmd['platform'].lower()        if cmd['output'] : config['resultDir'] = cmd['output']        if not cmd['port'] : port = '4723'        else : port = cmd['port']        report = ''        if cmd['report']: report = cmd['report']        caps = config['capability']        if os.path.splitext(cmd['app'])[1] == '.apk':            for k,v in config['androidCapability'].items():                if v: caps[k] = v        elif os.path.splitext(cmd['app'])[1] == '.ipa':            for k,v in config['iosCapability'].items():                if v: caps[k] = v        caps['showIOSLog'] = True        #debug        return config,caps,port,reportclass IosCrawler(Crawler):    def __init__(self,cmd):        super().__init__(cmd)        self.automationname = self.config['iosCapability']['automationName']        self.iosxcuiteststart = False    def issmall(self,e):        if 'width' not in e or not e['width'] or 'height' not in e or not e['height'] :return False        w = int(e['width'])        h = int(e['height'])        if w < 40 and h < 40: return True        return False    def isinbounds(self, e, e2):        if 'width' not in e or not e['width'] or 'height' not in e or not e['height']: return False        if 'width' not in e2 or not e2['width'] or 'height' not in e2 or not e2['height']: return False        x1 = e['x']        y1 = e['y']        w1 = e['width']        h1 = e['height']        x2 = e2['x']        y2 = e2['y']        w2 = e2['width']        h2 = e2['height']        if int(x2)>int(x1) and int(y2)>int(y1) and int(x2)-int(x1)+int(w2)<int(w1) and int(y2)-int(y1)+int(h2)<int(h1): return True        return False    def getappname(self):        name = ''        if self.automationname == 'XCUITest':            xpath = "//XCUIElementTypeApplication"        else:            xpath = "//UIApplication"        elements = self.getallelements(xpath, 0)        if elements:            if 'name' in elements[0]: name = elements[0]['name']            if name:return name        return ''    def geturl(self):        url =[]        screenname = ''        if self.appname: url.append(self.appname)        if self.automationname == 'XCUITest':            xpath = "//XCUIElementTypeNavigationBar"        else:            xpath = "//UIANavigationBar"        nodes = self.getallelements(xpath, 0)        for node in nodes:            if 'name' in node:screenname = node['name']            if screenname: url.append(screenname)        xpath = ''        if self.config['defineUrl']:            for xpath in self.config['defineUrl']:                baselist = self.getallelements(xpath,0)                if baselist:                    for base in baselist:                        if 'attribute' in base:                            base['attribute'] and url.append(base['attribute'])                        else:                            'label' in base and base['label'] and url.append(base['label']) \                            or 'name' in base and base['name'] and url.append(base['name'])        url = self.distinct(url)        if not url : return 'Launcher'        return '-'.join(url)    def getcontenthash(self):        if self.automationname == 'XCUITest':            xpath = "//*[not(ancestor-or-self::XCUIElementTypeStatusBar)]"        else:            xpath = "//*[not(ancestor-or-self::UIAStatusBar)]"        nodes = self.getallelements(xpath, 0)        str = ''        try:            for node in nodes:                s = ''                if 'tag' in node and \                                node['tag'] in self.config['schemaBlackList']: continue                for x in ['xpath', 'value', 'selected', 'text']:                    if x in node and node[x]: s += node[x]                str += s + '\n'        except Exception as e:            return self.md5('None')        return self.md5(str)    def doback(self):        if self.backdistance.interval() < 4:            logobj.warn('two back action to close!')            time.sleep(4)        ret = appiumdriver.asynctask(appiumdriver.iosback, self.driver)        self.backdistance.append('back')        if ret: self.appnamerecord.pop()    def dobackapp(self):        if self.config['defaultBackAction']:            for backaction in self.config['defaultBackAction']:                appiumdriver.dsl(self.driver, backaction)        else:            appiumdriver.launchapp(self.driver)    def refreshpage(self):        self.currentpagesource = ''        self.currentpagesource = appiumdriver.asynctask(appiumdriver.getpagesource, self.driver , timeout=90)        #self.currentpagesource = self.driver.page_source        if self.currentpagesource:            self.parsepagecontext()            if self.getelementaction() == 'back' and self.currenturl in self.needswipe :                logobj.debug('needswipe=%s, need swipeto up' % self.needswipe)                for action in self.config['beforeRefreshpageAction']:                    appiumdriver.asynctask(appiumdriver.dsl, self.driver, action)                self.needswipe.remove(self.currenturl)                self.swiperetry += 1            return True        else:            self.setelementaction('back')            return False    def findelementbyurlelement(self,urlelement):        xpath = urlelement.loc.replace('/AppiumAUT', '')        webelements = appiumdriver.find(self.driver, appiumdriver.By.XPATH, xpath)        if webelements: return webelements[0]        return None    def iosxcuitestclient(self):        logobj.info('start ios xcuitest client! ')        appiumdriver.asynctask(self.startiosclient, timeout=3)        while not self.iosxcuiteststart :            logobj.debug('/////////////////////// iosxcuitest client start time=%s!)))))))))))))))))))))))))))))'%(time.time()-self.iosxcuiteststarttime))            if time.time()-self.iosxcuiteststarttime>150:                logobj.error('-----------------------------iOS XCUItest not started maybe hang-up!restart client!+++++++++++++++++++++++++++++')                try:                    self.startserver()                    appiumdriver.asynctask(self.startiosclient, timeout=3)                    logobj.info('++++++++++++++++++++++++++++++++iOS XCUItest restarting---------------------------------')                except Exception as e:                    logobj.error('iosxcuitest client start failed!')                    logobj.error(e)            time.sleep(5)    def startiosclient(self,**kw):        if self.iosxcuiteststart: return        self.iosxcuiteststarttime = time.time()        self.driver = appiumdriver.startappiumclient(self.url, self.caps)        self.iosxcuiteststart = True    def startclient(self):        if os.path.splitext(self.apppath)[1] != '.apk' and os.path.splitext(self.apppath)[1] != '.ipa':            self.url = 'http://127.0.0.1:%s/wd/hub' % self.port            if self.config['iosCapability']['automationName'] == 'XCUITest': self.iosxcuitestclient()            else: self.driver = appiumdriver.startappiumclient(self.url, self.caps)            logobj.info('start appium client, url=%s' % self.url)        else:            self.caps['noReset'] = True            self.url = 'http://127.0.0.1:%s/wd/hub' % self.port            if self.adb: self.adb.installsucc = True            self.maybedialog = True            if self.config['iosCapability']['automationName'] == 'XCUITest': self.iosxcuitestclient()            else: self.driver = appiumdriver.startappiumclient(self.url, self.caps)            logobj.info('start appium client, url=%s' % self.url)        time.sleep(1)    def restartclient(self):        self.url = 'http://127.0.0.1:%s/wd/hub' % self.port        self.caps['noReset'] = True        if self.config['iosCapability']['automationName'] == 'XCUITest':self.iosxcuitestclient()        else: self.driver = appiumdriver.startappiumclient(self.url, self.caps)        logobj.info('restart appium client, url=%s' % self.url)        time.sleep(1)    def start(self):        self.registctrlc()        self.startserver()        time.sleep(5)        self.startclient()        self.iosxcuiteststart = True        appiumdriver.asynctask(self.appiummonitor, timeout=3)        self.screenheight, self.screenwigth = appiumdriver.getscreenhw(self.driver)        time.sleep(5)        self.startupscript()        self.appwhitelist.append(self.appnamerecord.last())        keep = True        execption = 0        while keep:            try:                self.recursivenum = 0                keep = self.crawl()                logobj.debug('recursive num = %s' % self.recursivenum)            except Exception as e:                logobj.error(e)                execption += 1                time.sleep(60)                if execption > 10:                    keep = False        self.stop(None, None)        # self.registctrlc()        # self.st artclient()        # print('gogo')        # time.sleep(15)        # self.refreshpage()        # #appname = self.getappname()        # #print(appname)        # #url = self.geturl()        # #print(url)        # #hash = self.getcontenthash()        # print('1')        # t1 = time.time()        #        # elements = appiumdriver.find(self.driver, appiumdriver.By.XPATH,"/XCUIElementTypeApplication/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther[2]/XCUIElementTypeOther/XCUIElementTypeCollectionView/XCUIElementTypeCell[8]/XCUIElementTypeImage[1]")        # #"//XCUIElementTypeButton[@name='id_closeBtn']")        # #AppiumAUT/        # #elements = appiumdriver.find(self.driver, appiumdriver.By.ID, "id_closeBtn")        # t2 = time.time()        # appiumdriver.asynctask(elements[0].click)        # t3 = time.time()        # print('t2-t1')        # print(t2-t1)        # print('t3-t2')        # print(t3-t2)def cmd():    usage = "python monkey.py -a pandatv.apk -c conf\pandatv.yml -r %s%sresult%s2017_01_24_12_00_00_testreport.html"%(os.path.split(os.path.realpath(__file__))[0],os.path.sep,os.path.sep)    cmd = OptionParser(usage)    cmd.add_option("-a", "--app", type="string", dest="app")    cmd.add_option("-c", "--config", type="string", dest="config")    cmd.add_option("-p", "--platform", type="string", dest="platform",default='android')    cmd.add_option("-t", "--maxtime", type="int", dest="maxtime",default=None)    cmd.add_option("-u", "--port", type="string", dest="port",default='4723')    cmd.add_option("-o", "--output", type="string", dest="output" ,default=None)    cmd.add_option("-i", "--udid", type="string", dest="udid")    cmd.add_option("-r", "--report", type="string", dest="report",default=None)    cmd.add_option("-d", "--driver", type="string", dest="appium",default=None)    (options, args) = cmd.parse_args()    #debug    options = {}    # test android    options['app'] = '%s%sconf%sapp-androidqa-release-3.1.8.3961.apk'%(os.path.split(os.path.realpath(__file__))[0],os.path.sep,os.path.sep)    options['config'] = '%s%sconf%spanda.yml'%(os.path.split(os.path.realpath(__file__))[0],os.path.sep,os.path.sep)    options['appium'] = None    options['output'] = None    options['platform'] = 'android'    options['udid'] = 'NBS4PRO76H59GESS'        #'X2P0215518002631'    options['maxtime'] = None    options['port'] = '4723'    options['report'] = None    options['report'] = 'D:\\automonkey\\result\\2017_01_24_12_00_00_testreport.html'    #    # # #test ios    # # options['app'] = '%s%sconf%sPandaTV-ios_2.2.7.1596.ipa'%(os.path.split(os.path.realpath(__file__))[0],os.path.sep,os.path.sep)    # # #options['app'] = '%s%sconf%sAurora_test.ipa'%(os.path.split(os.path.realpath(__file__))[0], os.path.sep, os.path.sep)    # # options['config'] = '%s%sconf%spanda-ios.yml'%(os.path.split(os.path.realpath(__file__))[0],os.path.sep,os.path.sep)    # # options['appium'] = None    # # options['output'] = None    # # options['platform'] = 'iOS'    # # options['udid'] = '3ffa4b9d0f867523c7055750f6987b39d0bc6fb8'    # # #'d51a8529926e21972ce7c40cd6e2a0c1c988139f'    # # #'3ffa4b9d0f867523c7055750f6987b39d0bc6fb8'    # # options['maxtime'] = None    # # options['port'] = '4723'    # # options['report'] = None    #    # print(options)    #debug#cd C:\Program Files (x86)\Appium\node_modules\appium#"C:\Program Files (x86)\Appium\node.exe" --max-old-space-size=2047 --gc-global lib\server\main.js --address 127.0.0.1 --port 4723 --platform-name Android --platform-version 23 --automation-name Appium --device-name "8681-M02-0x27a130ff" --log-no-color    return options#mac  python3 monkey.py -a conf/pandalive.apk -c conf/panda.yml -p android -i X2P0215518002631 -u 4723#win  python monkey.py -a conf\pandalive.apk -c conf\panda.yml -p android -i X2P0215518002631 -u 4723if __name__ == "__main__":    opt = cmd()    #debug    app = opt['app']    #debug    #cmd    #app = opt.app    #cmd    if os.path.splitext(app)[1] =='.apk':        Cr = Crawler(opt)    elif os.path.splitext(app)[1] == '.ipa':        Cr = IosCrawler(opt)    else:        logobj.error('app args error!')        sys.exit()    Cr.start()# 因爱而生忧，因爱而生怖；或使离爱者，无忧亦无怖